<HTML>
<HEAD>
<TITLE>setbuf(3)</TITLE>
</HEAD>
<BODY>
<H1>setbuf(3)</H1>
<HR>
<PRE>
<B>NAME</B>
     setbuf, setvbuf - assign buffering to a stream

<B>SYNOPSIS</B>
     <B>#include</B> <B>&lt;stdio.h&gt;</B>

     <B>int</B> <B>setbuf(FILE</B> <B>*</B><I>stream</I><B>,</B> <B>char</B> <B>*</B><I>buf</I><B>)</B>
     <B>int</B> <B>setvbuf(FILE</B> <B>*</B><I>stream</I><B>,</B> <B>char</B> <B>*</B><I>buf</I><B>,</B> <B>int</B> <I>type</I><B>,</B> <B>size_t</B> <I>size</I><B>)</B>

<B>DESCRIPTION</B>
     The three types of buffering available are  unbuffered,  block  buffered,
     and  line  buffered.   When  an  output stream is unbuffered, information
     appears on the destination file or terminal as soon as written;  when  it
     is  block  buffered  many characters are saved up and written as a block;
     when it is line buffered characters are  saved  up  until  a  newline  is
     encountered  or  input is read from stdin.  <B>Fflush</B> (see <B><A HREF="../man3/fclose.3.html">fclose(3)</A></B>) may be
     used to force  the  block  out  early.   Normally  all  files  are  block
     buffered.   A  buffer  is  obtained from <B><A HREF="../man3/malloc.3.html">malloc(3)</A></B> upon the first <B>getc</B> or
     <B><A HREF="../man3/putc.3.html">putc(3)</A></B> on the file.  If the standard stream <B>stdout</B> refers to a  terminal
     it is line buffered.  The standard stream <B>stderr</B> is always unbuffered.

     <B>Setbuf</B> is used after a stream has been opened but before it  is  read  or
     written.   The  character  array  <I>buf</I> is used instead of an automatically
     allocated buffer.  If <I>buf</I> is the constant pointer <B>NULL</B>, input/output will
     be  completely  unbuffered.   A manifest constant <B>BUFSIZ</B> tells how big an
     array is needed:

          <B>char</B> buf[BUFSIZ];

     <B>Setvbuf</B>, an alternate form of <B>setbuf</B>, is used after  a  stream  has  been
     opened but before it is read or written.  It has three uses, depending on
     the value of the <I>type</I> argument:

     <B>setvbuf(</B><I>stream</I><B>,</B> <I>buf</I><B>,</B> <B>_IOFBF,</B> <I>size</I><B>)</B>
          Causes input/output to be fully buffered using the  character  array
          <I>buf</I>  whose  size  is determined by the <I>size</I> argument.  If <I>buf</I> is the
          constant pointer <B>NULL</B>, then an automatically allocated  buffer  will
          be used.

     <B>setvbuf(</B><I>stream</I><B>,</B> <I>buf</I><B>,</B> <B>_IOLBF,</B> <I>size</I><B>)</B>
          Like above, except that output  will  be  line  buffered,  i.e.  the
          buffer  will  be  flushed  when  a newline is written, the buffer is
          full, or input is requested.

     <B>setvbuf(</B><I>stream</I><B>,</B> <I>buf</I><B>,</B> <B>_IONBF,</B> <I>size</I><B>)</B>
          Causes input/output to be completely unbuffered.  <I>Buf</I> and  <I>size</I>  are
          ignored.



     A file can  be  changed  between  unbuffered,  line  buffered,  or  block
     buffered  by  using  <B>freopen</B>  (see  <B><A HREF="../man3/fopen.3.html">fopen(3)</A></B>) followed by the appropriate
     <B>setvbuf</B> call.

<B>SEE</B> <B>ALSO</B>
     <B><A HREF="../man3/fopen.3.html">fopen(3)</A></B>, <B><A HREF="../man3/getc.3.html">getc(3)</A></B>, <B><A HREF="../man3/putc.3.html">putc(3)</A></B>,  <B><A HREF="../man3/malloc.3.html">malloc(3)</A></B>,  <B><A HREF="../man3/fclose.3.html">fclose(3)</A></B>,  <B><A HREF="../man3/puts.3.html">puts(3)</A></B>,  <B><A HREF="../man3/printf.3.html">printf(3)</A></B>,
     <B><A HREF="../man3/fread.3.html">fread(3)</A></B>.











































</PRE>
</BODY>
</HTML>
